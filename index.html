<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Smart Image Compressor</title>

<style>
    body {
        margin:0;
        padding:0;
        background:#000;
        font-family: 'Poppins', sans-serif;
        color:white;
        text-align:center;
    }

    .container {
        padding:20px;
    }

    /* Neon Instagram Glow */
    .neon-box {
        width:170px;
        height:85px;
        margin:20px auto;
        border-radius:15px;
        background: rgba(255, 255, 255, 0.05);
        border:2px dashed rgba(255,255,255,0.4);
        display:flex;
        align-items:center;
        justify-content:center;
        cursor:pointer;
        transition:0.3s;
        box-shadow:0 0 8px #ff00ff, 0 0 12px #ff9900;
    }

    .neon-box:hover {
        box-shadow:0 0 15px #ff00ff, 0 0 20px #ff9900;
    }

    #fileInput { display:none; }

    #info {
        margin-top:10px;
        font-size:15px;
        color:#bbb;
    }

    #outputBox {
        margin-top:20px;
        display:none;
    }

    .download-btn {
        display:inline-block;
        margin-top:15px;
        padding:10px 22px;
        border-radius:12px;
        background:linear-gradient(45deg,#ff00cc,#ff9900,#ff006a);
        color:white;
        font-weight:600;
        text-decoration:none;
        box-shadow:0 0 10px #ff00cc;
    }
</style>
</head>

<body>
<div class="container">

    <h2>Smart Image Compressor</h2>
    
    <!-- Drag/Click Box -->
    <div class="neon-box" id="dropZone">
        Tap or Drop File
    </div>

    <input type="file" id="fileInput" accept="image/*">

    <div id="info"></div>

    <div id="outputBox">
        <h3>Compressed File Ready</h3>
        <div id="resultSizes"></div>
        <a id="downloadLink" class="download-btn" download="compressed.jpg">Download</a>
    </div>

</div>

<script>
function formatSize(bytes) {
    let kb = (bytes / 1024).toFixed(2);
    let mb = (bytes / 1024 / 1024).toFixed(2);
    return `${kb} KB (${mb} MB)`;
}

async function compressImage(file) {

    const maxSizeMB = 2;  // target <= 2MB
    const maxBytes = maxSizeMB * 1024 * 1024;

    return new Promise(resolve => {

        const img = new Image();
        const reader = new FileReader();

        reader.onload = e => {
            img.src = e.target.result;
        };

        img.onload = () => {

            let canvas = document.createElement('canvas');
            let ctx = canvas.getContext('2d');

            // scale down if too large
            let scale = 1;
            const MAX_DIM = 2000;

            if (img.width > MAX_DIM || img.height > MAX_DIM) {
                scale = Math.min(MAX_DIM / img.width, MAX_DIM / img.height);
            }

            canvas.width = img.width * scale;
            canvas.height = img.height * scale;

            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            let quality = 0.9;  
            let compressed = canvas.toDataURL('image/jpeg', quality);

            while (compressed.length > maxBytes && quality > 0.08) {
                quality -= 0.08;
                compressed = canvas.toDataURL('image/jpeg', quality);
            }

            // If still too large â†’ reduce resolution more
            let blob = dataURLtoBlob(compressed);
            if (blob.size > maxBytes) {
                let extraScale = 0.8;
                while (blob.size > maxBytes && extraScale > 0.30) {
                    canvas.width *= extraScale;
                    canvas.height *= extraScale;

                    ctx = canvas.getContext("2d");
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

                    compressed = canvas.toDataURL("image/jpeg", 0.7);
                    blob = dataURLtoBlob(compressed);
                    extraScale -= 0.15;
                }
            }

            resolve(blob);
        };

        reader.readAsDataURL(file);
    });
}

function dataURLtoBlob(dataurl) {
    let arr = dataurl.split(","),
    mime = arr[0].match(/:(.*?);/)[1],
    bstr = atob(arr[1]),
    n = bstr.length,
    u8arr = new Uint8Array(n);

    while (n--) u8arr[n] = bstr.charCodeAt(n);
    return new Blob([u8arr], { type: mime });
}

document.getElementById("dropZone").onclick = () => {
    document.getElementById("fileInput").click();
};

document.getElementById("dropZone").ondragover = e => {
    e.preventDefault();
};

document.getElementById("dropZone").ondrop = e => {
    e.preventDefault();
    handleFile(e.dataTransfer.files[0]);
};

document.getElementById("fileInput").onchange = e => {
    handleFile(e.target.files[0]);
};

async function handleFile(file) {
    if (!file) return;

    document.getElementById("info").innerHTML =
        `<b>Original Size:</b> ${formatSize(file.size)}`;

    const compressedBlob = await compressImage(file);

    document.getElementById("resultSizes").innerHTML = `
        <b>Compressed Size:</b> ${formatSize(compressedBlob.size)}
    `;

    const url = URL.createObjectURL(compressedBlob);
    document.getElementById("downloadLink").href = url;

    document.getElementById("outputBox").style.display = "block";
}
</script>

</body>
</html>
