<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Ultra Image Compressor — Neon Tech (Created by Animesh)</title>

<!-- JSZip CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

<style>
  :root{
    --bg1:#0b0f17; --bg2:#061021;
    --card:#07121a; --accent1:#00ffe1; --accent2:#ff3dff;
    --muted:#98a0b3; --glass: rgba(255,255,255,0.03);
  }
  html,body{height:100%; margin:0; font-family:Inter,Segoe UI,Roboto,Arial; color:#dfe9ff; background: radial-gradient(1200px 600px at 10% 10%, rgba(0,70,80,0.12), transparent), linear-gradient(180deg,var(--bg1),var(--bg2)); -webkit-font-smoothing:antialiased;}
  .wrap{max-width:1100px;margin:28px auto;padding:20px;}
  header{display:flex;align-items:center;justify-content:space-between;gap:16px}
  h1{margin:0;font-size:20px;letter-spacing:0.4px}
  .small{font-size:13px;color:var(--muted)}
  /* neon drop zone */
  .drop {
    margin-top:18px;
    border-radius:14px;
    padding:26px;
    text-align:center;
    position:relative;
    border:1px solid rgba(255,255,255,0.04);
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    box-shadow: 0 8px 40px rgba(0,0,0,0.45), 0 0 40px rgba(0,0,0,0.2) inset;
    transition: transform .12s ease, box-shadow .12s;
    cursor: pointer;
    overflow:hidden;
  }
  .drop:hover{transform: translateY(-4px)}
  .drop::before{
    content:''; position:absolute; inset:0; pointer-events:none;
    background: linear-gradient(90deg, rgba(0,255,225,0.05), rgba(255,61,255,0.035));
    mix-blend-mode: screen; filter: blur(8px);
  }
  .glow-outline{
    position:absolute; inset:-2px; border-radius:16px; pointer-events:none;
    box-shadow: 0 0 30px rgba(0,255,230,0.08), 0 0 80px rgba(255,61,255,0.03) inset;
  }
  .drop h2{margin:0;font-size:18px}
  .drop p{margin:8px 0 0;color:var(--muted);font-size:13px}

  /* controls panel */
  .controls {display:flex;gap:12px;align-items:center;margin-top:14px;flex-wrap:wrap}
  .range {display:flex;gap:10px;align-items:center}
  input[type="range"]{width:220px}
  .btn {padding:10px 14px;border-radius:10px;border:0;cursor:pointer;font-weight:700;letter-spacing:0.4px}
  .btn.neon {background: linear-gradient(90deg,var(--accent1),var(--accent2)); color:#041018; box-shadow: 0 6px 30px rgba(0,255,225,0.10)}
  .btn.ghost {background:transparent;border:1px solid rgba(255,255,255,0.06); color:var(--muted)}
  .toggle {display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.04)}

  /* gallery */
  .grid {display:grid;grid-template-columns:repeat(1,1fr);gap:14px;margin-top:18px}
  @media(min-width:920px){ .grid{grid-template-columns:repeat(2,1fr)} }

  .card {
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius:12px;padding:14px;position:relative;border:1px solid rgba(255,255,255,0.04);
    box-shadow: 0 12px 40px rgba(0,0,0,0.6);
  }
  .card .row{display:flex;gap:14px;align-items:flex-start}
  .thumb {width:220px;flex-shrink:0;border-radius:10px;overflow:hidden;border:1px solid rgba(255,255,255,0.03)}
  .thumb img{display:block;width:100%;height:auto}
  .meta {flex:1}
  .meta .title{font-weight:800;color:#fff;margin-bottom:6px}
  .meta .info{font-size:13px;color:var(--muted);line-height:1.6}
  .outputs{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:12px}
  .out {
    background: rgba(0,0,0,0.28);
    border-radius:8px;padding:8px;border:1px solid rgba(255,255,255,0.03);
    display:flex;flex-direction:column;gap:8px;
  }
  .out .label{font-size:12px;color:var(--muted);font-weight:700}
  .out .res{font-weight:800;color:#fff}
  .out .small{font-size:12px;color:var(--muted)}
  .out .actions{display:flex;gap:8px;margin-top:6px}
  .a-btn{padding:8px 10px;border-radius:8px;border:0;background:linear-gradient(90deg,#00ffd0,#9f00ff);color:#041018;font-weight:700;cursor:pointer}

  .download-all {margin-top:16px;text-align:center}
  .download-all .btn {padding:10px 16px;border-radius:10px}

  /* before-after slider */
  .ba {position:relative;border-radius:8px;overflow:hidden;border:1px solid rgba(255,255,255,0.04)}
  .ba img{display:block;width:100%;height:auto}
  .ba .after {position:absolute;top:0;left:0;height:100%;overflow:hidden;width:50%}
  .ba .handle {position:absolute;left:50%;top:0;bottom:0;width:3px;background:linear-gradient(180deg,#00ffe1,#ff3dff);cursor:ew-resize;transform:translateX(-50%)}
  .note{font-size:12px;color:var(--muted);margin-top:6px}

  footer{margin-top:18px;text-align:center;color:var(--muted);font-size:12px}
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Ultra Image Compressor <span class="small">— Neon Tech UI</span></h1>
        <div class="small">Created by Animesh</div>
      </div>
      <div style="display:flex;gap:12px;align-items:center">
        <div class="toggle" id="darkToggle">Dark</div>
        <button class="btn ghost" id="helpBtn">Help</button>
      </div>
    </header>

    <div class="drop" id="dropZone">
      <div class="glow-outline"></div>
      <h2>Click or Drag & Drop images here</h2>
      <p class="small">Supports JPG/PNG/HEIC/etc — multiple images allowed. All processing is local in your browser.</p>
      <input id="fileInput" type="file" accept="image/*" multiple style="display:none" />
    </div>

    <div class="controls">
      <div class="range">
        <label class="small" style="min-width:88px">Quality</label>
        <input id="quality" type="range" min="20" max="95" value="78">
        <div id="qLabel" class="small">78%</div>
      </div>

      <button class="btn neon" id="clearAll">Clear All</button>
      <button class="btn ghost" id="toggleMode">Toggle Mobile Reduce: ON</button>
    </div>

    <div class="grid" id="gallery"></div>

    <div class="download-all">
      <button class="btn neon" id="downloadZip">Download All as ZIP</button>
    </div>

    <footer>Created by Animesh — Ultra Image Compressor</footer>
  </div>

<script>
/* Neon Tech Image Compressor
   - Creates 4 outputs per image automatically:
     A) Same Format - original resolution
     B) WebP - original resolution
     C) Same Format - reduced/mobile resolution
     D) WebP - reduced/mobile resolution
   - Shows format, resolution, size, reduction%
   - Provides download links and ZIP pack
*/

const dropZone = document.getElementById('dropZone');
const fileInput = document.getElementById('fileInput');
const gallery = document.getElementById('gallery');
const qualitySlider = document.getElementById('quality');
const qLabel = document.getElementById('qLabel');
const clearAllBtn = document.getElementById('clearAll');
const downloadZipBtn = document.getElementById('downloadZip');
const toggleModeBtn = document.getElementById('toggleMode');

let mobileReduceEnabled = true;
let zipItems = []; // {name, blob}

qLabel.innerText = qualitySlider.value + '%';
qualitySlider.oninput = () => qLabel.innerText = qualitySlider.value + '%';

dropZone.addEventListener('click', () => fileInput.click());
dropZone.addEventListener('dragover', (e)=>{ e.preventDefault(); dropZone.style.transform='translateY(-6px)'; });
dropZone.addEventListener('dragleave', ()=> dropZone.style.transform='none');
dropZone.addEventListener('drop', (e)=>{ e.preventDefault(); dropZone.style.transform='none'; handleFiles(e.dataTransfer.files); });
fileInput.addEventListener('change', ()=> handleFiles(fileInput.files));

clearAllBtn.addEventListener('click', ()=> {
  gallery.innerHTML=''; zipItems=[]; alert('Cleared all processed images.');
});

toggleModeBtn.addEventListener('click', ()=> {
  mobileReduceEnabled = !mobileReduceEnabled;
  toggleModeBtn.textContent = `Toggle Mobile Reduce: ${mobileReduceEnabled ? 'ON' : 'OFF'}`;
});

// Helpers
function bytesToMB(b){ return (b/1024/1024).toFixed(3); }
function bytesToKB(b){ return (b/1024).toFixed(1); }
function percentReduce(orig, now){ return ((orig - now)/orig*100).toFixed(2); }
function formatExt(mime){ return mime.split('/')[1].split('+')[0]; }

// Reduced resolution heuristic (mobile friendly)
function computeReducedDims(w,h){
  const MAX = 720; // mobile-friendly width
  if (w <= MAX && h <= MAX) return {w,h};
  const ratio = w/h;
  if (w >= h){ // landscape
    const newW = Math.min(w, MAX);
    const newH = Math.round(newW / ratio);
    return {w:newW,h:newH};
  } else {
    const newH = Math.min(h, MAX);
    const newW = Math.round(newH * ratio);
    return {w:newW,h:newH};
  }
}

// Main
async function handleFiles(fileList){
  const files = Array.from(fileList);
  for (const file of files){
    if (!file.type.startsWith('image/')) continue;
    await processFile(file);
  }
}

async function processFile(file){
  // create a FileReader and image
  const dataUrl = await readFileAsDataURL(file);
  const img = await createImage(dataUrl);

  const origRes = {w: img.width, h: img.height};
  const origSize = file.size;

  // prepare reduced dims
  const reducedDims = computeReducedDims(img.width, img.height);

  // create four outputs by drawing to canvas accordingly
  // Respect quality slider
  const quality = Number(qualitySlider.value)/100;

  // Use a helper to get dataURL+blob for a canvas config
  async function makeOutput({mime, width, height, qualityVal}) {
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');
    // draw with smoothing
    ctx.imageSmoothingQuality = 'high';
    ctx.drawImage(img, 0, 0, width, height);
    // toDataURL then blob
    const dataURL = canvas.toDataURL(mime, qualityVal);
    const blob = await (await fetch(dataURL)).blob();
    return {dataURL, blob, mime, w:width, h:height};
  }

  // Define outputs
  const outputsDef = [
    {id:'same_orig', label:'Best Same Format (Original Res)', mime: file.type, width: img.width, height: img.height, qualityVal: quality},
    {id:'webp_orig', label:'Best WebP (Original Res)', mime: 'image/webp', width: img.width, height: img.height, qualityVal: quality},
    {id:'same_reduced', label:'Best Same Format (Reduced Res)', mime: file.type, width: mobileReduceEnabled ? reducedDims.w : img.width, height: mobileReduceEnabled ? reducedDims.h : img.height, qualityVal: quality},
    {id:'webp_reduced', label:'Best WebP (Reduced Res)', mime: 'image/webp', width: mobileReduceEnabled ? reducedDims.w : img.width, height: mobileReduceEnabled ? reducedDims.h : img.height, qualityVal: quality},
  ];

  // show card UI immediately with placeholders
  const card = document.createElement('div'); card.className = 'card';
  card.innerHTML = `
    <div class="row">
      <div class="thumb"><img src="${dataUrl}" alt="thumb"></div>
      <div class="meta">
        <div class="title">${escapeHtml(file.name)}</div>
        <div class="info">Original: <b>${origRes.w} × ${origRes.h}</b> • ${bytesToKB(origSize)} KB (${bytesToMB(origSize)} MB) • ${file.type}</div>
        <div class="note" style="margin-top:10px">Auto-generating 4 optimized outputs — this runs locally. Quality: <b>${Math.round(quality*100)}%</b></div>
        <div class="outputs" id=""></div>
      </div>
    </div>
    <div style="margin-top:12px">
      <div class="ba" style="margin-top:10px">
        <img class="before" src="${dataUrl}" alt="before">
        <div class="after"><img src="${dataUrl}" alt="after"></div>
        <div class="handle"></div>
      </div>
      <div class="note">Drag the handle to compare original vs currently selected optimized output. Click an output's "Use for Compare" to preview it.</div>
    </div>
  `;
  gallery.prepend(card);

  const outputsContainer = card.querySelector('.outputs');
  const baAfter = card.querySelector('.after');
  const baHandle = card.querySelector('.handle');
  const beforeImg = card.querySelector('.before');

  // initialize slider for before/after
  initBeforeAfter(card);

  // Create DOM elements for outputs
  const outputsDom = {};
  for (const def of outputsDef){
    const outEl = document.createElement('div'); outEl.className = 'out';
    outEl.innerHTML = `
      <div class="label">${def.label}</div>
      <div class="res">Res: <span class="resVal">calculating...</span></div>
      <div class="small">Format: <span class="fmt">-</span> • Size: <span class="sizeVal">-</span></div>
      <div class="small">Reduction: <span class="pct">-</span></div>
      <div class="actions">
        <button class="a-btn use">Use for Compare</button>
        <button class="a-btn download">Download</button>
      </div>
    `;
    outputsContainer.appendChild(outEl);
    outputsDom[def.id] = {def, el: outEl};
  }

  // generate outputs sequentially (so UI updates)
  for (const def of outputsDef){
    const dom = outputsDom[def.id];
    try{
      const res = await makeOutput(def);
      const size = res.blob.size;
      const reductionPct = percentReduce(origSize, size);
      // fill DOM
      dom.el.querySelector('.resVal').textContent = `${res.w}×${res.h}`;
      dom.el.querySelector('.fmt').textContent = res.mime;
      dom.el.querySelector('.sizeVal').textContent = `${bytesToKB(size)} KB (${bytesToMB(size)} MB)`;
      dom.el.querySelector('.pct').textContent = `${reductionPct}%`;
      // download
      const downloadBtn = dom.el.querySelector('.download');
      const useBtn = dom.el.querySelector('.use');
      const ext = formatExt(res.mime);
      const baseName = (file.name||'image').replace(/\.[^/.]+$/, '');
      const outName = `${baseName}_${def.id}.${ext}`;

      const blobURL = URL.createObjectURL(res.blob);
      downloadBtn.addEventListener('click', ()=>{
        triggerDownload(blobURL, outName);
      });

      useBtn.addEventListener('click', ()=>{
        // set after image to this optimized blob
        baAfter.innerHTML = `<img src="${blobURL}" style="display:block;width:100%;">`;
      });

      // add to zip list
      zipItems.push({name: outName, blob: res.blob});

    } catch(err){
      dom.el.querySelector('.resVal').textContent = 'error';
      dom.el.querySelector('.sizeVal').textContent = 'error';
      dom.el.querySelector('.pct').textContent = 'error';
      console.error('makeOutput error', err);
    }
  }

  // helper to set default compare to WebP reduced if present
  const defaultKey = mobileReduceEnabled ? 'webp_reduced' : 'webp_orig';
  if (outputsDom[defaultKey]){
    outputsDom[defaultKey].el.querySelector('.use').click();
  }
}

// Utilities
function readFileAsDataURL(file){
  return new Promise((res,rej)=>{
    const fr = new FileReader();
    fr.onload = ()=> res(fr.result);
    fr.onerror = rej;
    fr.readAsDataURL(file);
  });
}
function createImage(dataURL){
  return new Promise((res,rej)=>{
    const img = new Image();
    img.onload = ()=> res(img);
    img.onerror = rej;
    img.src = dataURL;
  });
}
function triggerDownload(url, name){
  const a = document.createElement('a'); a.href = url; a.download = name; document.body.appendChild(a); a.click(); a.remove();
}
function escapeHtml(s){ return s.replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

// BEFORE-AFTER Handler
function initBeforeAfter(card){
  const ba = card.querySelector('.ba');
  const after = ba.querySelector('.after');
  const handle = ba.querySelector('.handle');
  let dragging = false;
  // initialize width 50%
  after.style.width = '50%';
  handle.style.left = '50%';

  const onMove = (clientX) => {
    const rect = ba.getBoundingClientRect();
    let pct = (clientX - rect.left) / rect.width;
    if (pct < 0) pct = 0; if (pct > 1) pct = 1;
    after.style.width = (pct*100)+'%';
    handle.style.left = (pct*100)+'%';
  };
  handle.addEventListener('pointerdown', (e)=>{ dragging = true; handle.setPointerCapture(e.pointerId); });
  window.addEventListener('pointerup', ()=> dragging = false);
  window.addEventListener('pointermove', (e)=>{ if(dragging) onMove(e.clientX); });

  // clicking outputs also sets after image (wired in processFile)
}

/* ZIP download */
downloadZipBtn.addEventListener('click', async ()=>{
  if (!zipItems.length){ alert('No optimized images yet. Compress images first.'); return; }
  downloadZipBtn.textContent = 'Preparing ZIP...'; downloadZipBtn.disabled = true;
  const zip = new JSZip();
  for (const it of zipItems){
    zip.file(it.name, it.blob);
  }
  try{
    const content = await zip.generateAsync({type:'blob'});
    const url = URL.createObjectURL(content);
    triggerDownload(url,'compressed_images.zip');
  } catch(e){
    console.error('ZIP error', e);
    alert('ZIP creation failed (see console).');
  }
  downloadZipBtn.textContent = 'Download All as ZIP'; downloadZipBtn.disabled = false;
});

</script>
</body>
</html>
